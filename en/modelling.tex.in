\newpage
\section{Basic Modelling in \ZincOrMiniZinc}\label{sec:modelling}

In this section we introduce the basic structure of a \ZincOrMiniZinc model using two simple examples.

\subsection{Our First Example}

\begin{figure}[htb]
\begin{center}
\includegraphics[height=5cm]{figures/aust}
\end{center}
\caption{Australian states.\label{fig:aust}}
\end{figure}

As our first example, imagine that we wish to colour a map
of Australia as shown in \autoref{fig:aust}.  
It is made up of seven different states and territories 
%\footnote{For the
% interested, non-Australian reader, these are: New South Wales, Northern Territory, Queensland, South Australia, Tasmania, Victoria and Western Australia.}
each of which must be given a  colour so that adjacent regions
have different colours. 

\begin{figure}
\insertlitcode{aust}
\caption{A \ZincOrMiniZinc model \texttt{aust.mzn} 
for colouring the states and territories
in Australia.\label{ex:aust}}
\end{figure}

\begin{litcode}{aust}{mzn}
% Colouring Australia using nc colours
int: nc = 3;

var 1..nc: wa;   var 1..nc: nt;  var 1..nc: sa;   var 1..nc: q;
var 1..nc: nsw;  var 1..nc: v;   var 1..nc: t;

constraint wa != nt;
constraint wa != sa;
constraint nt != sa;
constraint nt != q;
constraint sa != q;
constraint sa != nsw;
constraint sa != v;
constraint q != nsw;
constraint nsw != v;
solve satisfy;

output ["wa=\(wa)\t nt=\(nt)\t sa=\(sa)\n",
        "q=\(q)\t nsw=\(nsw)\t v=\(v)\n",
         "t=", show(t),  "\n"];
\end{litcode}
      
We can model this problem very easily in \ZincOrMiniZinc. The model is shown in \autoref{ex:aust}.
The first line in the model is a comment. A comment starts with a  `\%' which indicates that the rest of the line is a comment.
\ZincOrMiniZinc also has C-style block comments, 
which start with `/*' and end with `*/'.

The next part of the model declares the variables in the model.
The line
\begin{code}
int: nc = 3;
\end{code}
specifies a \emph{parameter}\index{parameter} in the problem which is the
number of colours to be used.
Parameters are similar to (constant) variables in most programming languages.
They must be
declared and given a type\index{type}. In this case the type is \?int?. 
They are given a value by an \emph{assignment}\index{assignment}.
\ZincOrMiniZinc allows the assignment to be included as part of the declaration
(as in the line above) or to be a separate assignment statement.
Thus the following is equivalent to the single line above
\begin{code}
int: nc;
nc = 3;
\end{code}
Unlike variables in many programming languages a parameter can only be given a
\emph{single} value, in that sense they are named constants.
It is an error for a parameter to occur in more than one assignment.

The basic parameter types\index{type!parameter} 
are integers\index{integer}
(\texttt{int}\ttindex{int}), 
floating point numbers  (\texttt{float}\ttindex{float}),
Booleans\index{Boolean} (\texttt{bool}\ttindex{bool}) and
strings\index{string} (\texttt{string}\ttindex{string}). 
Arrays and sets are also supported.

\ZincOrMiniZinc models can also contain another kind of variable called a
\emph{decision variable}\index{decision variable|see{variable}}\index{variable}.
Decision variables are variables in the sense of mathematical or logical
variables.
Unlike parameters and variables in a standard programming language, the
modeller does not need to give them a value.
Rather the value of a decision variable is unknown and it is only when the
\ZincOrMiniZinc model is executed that the solving system determines if the
decision variable can be assigned a value that satisfies the constraints in the
model and if so what this is.

In our example model  we associate a \emph{decision variable} with each region, 
$wa$, $nt$, $sa$, $q$, $nsw$, $v$ and $t$,
which stands for the (unknown) colour to be used to fill the region.

For each decision variable we need to give the set of possible values the
variable can take. This is called the variable's
\emph{domain}\index{domain}.  
This can be given as part of the variable 
declaration\index{variable!declaration} and the
type\index{type} of the decision variable is inferred from the type of the values in the domain.

In \ZincOrMiniZinc decision variables\index{type!decision} 
can be Booleans, integers, floating point numbers, 
 or sets. 
Also supported are arrays whose elements are 
decision variables.
In our \ZincOrMiniZinc model we use integers to model the different colours. Thus each of our
decision variables is declared to have the domain \texttt{1..nc}\ttindexs{..} 
which is an integer range expression\index{range!integer}
indicating the set $\{ 1, 2, ..., nc \}$
using the \texttt{var}\ttindex{var}
\index{var@\texttt{var}!int@\texttt{int}} declaration.
The type of the values is integer so all of the variables in the model are integer decision variables.

\defblock{Identifiers}{
Identifiers\index{identifier|textbf} 
which are used to name parameters and variables 
are sequences of lower and uppercase
alphabetic characters, digits and the underscore `\_' character. They must
start with a alphabetic character. Thus \texttt{myName\_2} is a valid
identifier.  MiniZinc (and Zinc)
\emph{keywords}\index{keywords} are not allowed to be 
used as identifier names, they are listed in 
\autoref{sec:keywords}.
%\hyperref[sec:keywords]{Appendix~\ref*{sec:keywords}}.
Neither are \ZincOrMiniZinc \emph{operators}\index{operator} 
allowed to be used as identifier names;
they are listed in 
\autoref{sec:operators}.
%\hyperref[sec:operators]{Appendix~\ref*{sec:operators}}.
}

\ZincOrMiniZinc carefully 
distinguishes between the two kinds of model variables:
parameters and decision variables. The kinds of expressions that can be
constructed using decision variables are more restricted than those that can
be built from parameters. However, in any place that a decision variable can be
used, so can a parameter of the same type.

\defblock{Integer Variable Declarations}{
An integer parameter variable\index{variable!declaration!integer} is declared as either:
\begin{quote}
  \texttt{\litkw{int}} \texttt{:} \qquote{\emph{var-name}} \\
  \qquote{\emph{l}} \texttt{..} \qquote{\emph{u}} \texttt{:} \qquote{\emph{var-name}}
\end{quote}
where \emph{l} and \emph{u} are fixed integer expressions.

An integer decision variable is declared
as either:\index{var@\texttt{var}!int@\texttt{int}|textbf}
\begin{quote}
  \texttt{\litkw{var}} \texttt{\litkw{int}} \texttt{:}
  \qquote{\emph{var-name}} \\
  \texttt{\litkw{var}} \qquote{\emph{l}} \texttt{..} \qquote{\emph{u}} \texttt{:} \qquote{\emph{var-name}}
\end{quote}
where \emph{l} and \emph{u} are fixed integer expressions.
}


Formally the distinction between parameters and decision variables is called
the \emph{instantiation} of the variable.
The combination of variable instantiation and type is called a
\emph{type-inst}\index{type-inst}. 
As you start to use \ZincOrMiniZinc you will undoubtedly see examples of
\emph{type-inst} errors.

The next component of the model are the \emph{constraints}\index{constraint}. 
These specify the Boolean expressions that the decision variables must satisfy
to be a valid solution to the model.
In this case we have a number of not equal constraints between the decision
variables enforcing that if two states are adjacent then they must have
different colours.

\defblock{Relational Operators}{
\ZincOrMiniZinc provides the relational operators\index{operator!relational|textbf}: 
equal (\texttt{=}\ttindexdefs{=} or \texttt{==}\ttindexdefs{==}), not equal 
(\texttt{!=}\index{{=}@\texttt{"!=}~|textbf}), 
strictly less than (\texttt{<}\ttindexdefs{<}), 
strictly greater than (\texttt{>}\ttindexdefs{>}), 
less than or equal to (\texttt{<=}\ttindexdefs{<=}), and
greater than or equal to (\texttt{>=}\ttindexdefs{>=}).
}
\pjs{Should we remove all uses of \texttt{==}?}

The next line in the model:
\begin{code}
solve satisfy;
\end{code}
indicates the kind of problem it is. 
In this case it is a \emph{satisfaction}\index{satisfaction} problem:
we wish to find a value for the 
decision variables that satisfies the constraints but we do not care which one.

The final part of the model is the \emph{output}\index{output} statement. This tells \ZincOrMiniZinc what to
print when the model has been run and a solution\index{solution} is found.  

\defblock{Output and Strings}{
\index{output|textbf}
\index{string|textbf}
An output statement is followed by a \emph{list} of strings. These are
typically either string literals\index{string!literal|textbf} 
which are written between double quotes and
use a C like notation for special characters, 
or an expression of the form 
\emph{show(e)}\index{show@\texttt{show}|textbf} 
where \emph{e} is the \ZincOrMiniZinc expression.
In the example \texttt{\textbackslash{}n} 
represents the newline character and \texttt{\textbackslash{}t} a
tab.

There are also formatted varieties of \emph{show} for numbers:
\emph{show\_int(n,X)}\index{showint@\texttt{show\_int}|textbf} 
outputs the value of integer 
\emph{X} in at least $|n|$ characters, right justified
if $n > 0$ and left justified otherwise;
\emph{show\_float(n,d,X)}\index{showfloat@\texttt{show\_float}|textbf} 
outputs the value of float \emph{X} in at least $|n|$ characters, right justified
if $n > 0$ and left justified otherwise, with $d$ characters after the
decimal point.




String literals\index{string!literal} must fit on a single line. Longer string literals can be
split across multiple lines using the string concatenation operator
\texttt{++}\ttindexdefs{++}
For example, the string literal
\texttt{"Invalid datafile: Amount of flour is non-negative"} 
is equivalent to
the string literal expression  
\texttt{"Invalid datafile: " ++} 
\\ \texttt{"Amount of flour is non-negative"}.  


\ZincOrMiniZinc supports 
interpolated strings\index{string!literal!interpolated|textbf}.
Expressions can be imbedded directly in string literals, 
where a sub string of the form \texttt{\textbackslash{}(}$e$\texttt{)} 
is replaced by the result of \texttt{show(}$e$\texttt{)}.
For example \texttt{"t=\textbackslash(t)\textbackslash{}n"} produces the same string as
\texttt{"t=" ++ show(t) ++ "\textbackslash{}n"}.


A model can contain at most one output statement.
}


With the G12 
implementation of \ZincOrMiniZinc we can evaluate our model by typing\\
\begin{cmd}
$ mzn-g12fd aust.mzn
\end{cmd} %$
\ttindex{mzn-g12fd}
where \texttt{aust.mzn} 
is the name of the file containing our \ZincOrMiniZinc model.
We must use the file extension ``.mzn'' to indicate a \ZincOrMiniZinc model.
The command \texttt{mzn-g12fd} uses the G12 finite domain solver to evaluate
our model. 

When we run this we obtain the result:
\begin{cmd}
wa=2	 nt=3	 sa=1
q=2	 nsw=3	 v=2
t=1
----------
\end{cmd}
The line of 10 dashes \texttt{-{}-{}-{}-{}-{}-{}-{}-{}-{}-}
\index{solution!separator \texttt{-{}-{}-{}-{}-{}-{}-{}-{}-{}-}}
\ttindexdefs{-{}-{}-{}-{}-{}-{}-{}-{}-{}-} is output automatically added
by the \ZincOrMiniZinc output to indicate a solution has been found. 

%We might now want to see if we can colour the map of Australia with two colours.
%We can change the first line 


%\subsection{A Second Example}

%As our second simple example, consider the
%crypto-arithmetic problem:
%\begin{center}
%\begin{tabular}{llllll}
%&& S & E & N&D \\
%+&&M & O & R& E \\ \hline
%=& M & O & N & E & Y
%\end{tabular}
%\end{center}
%where each letter represents a different digit
%and the arithmetic equation
%holds.
%This is modelled by the \ZincOrMiniZinc model:

%send-more money
%all different built in constraints complex output

%cake production
%optimization problem
%data file (amount of each ingredient in the pantry)
%assert to check non-negative amount

\subsection{An Arithmetic Optimisation Example}

\begin{figure}
\insertlitcode{cakes}
\begin{litcode}{cakes}{mzn}
% Baking cakes for the school fete

var 0..100: b; % no. of banana cakes
var 0..100: c; % no. of chocolate cakes

% flour
constraint 250*b + 200*c <= 4000;
% bananas
constraint 2*b  <= 6;
% sugar
constraint 75*b + 150*c <= 2000;
% butter
constraint 100*b + 150*c <= 500;
% cocoa
constraint 75*c <= 500;

% maximize our profit
solve maximize 400*b + 450*c;

output ["no. of banana cakes = \(b)\n",
         "no. of chocolate cakes = \(c)\n"];
\end{litcode}
\caption{Model for determining how many banana and chocolate cakes to bake
  for the school fete.\label{ex:cakes}}
\end{figure}

Our second example is motivated by the need to bake some cakes for a fete at
our local school.
We know how to make two sorts of cakes.\footnote{WARNING: please don't use
these recipes at home}
A banana cake which takes 250g of self-raising flour, 2 mashed bananas, 75g
sugar and 100g of butter, and a chocolate cake which takes 200g of self-raising
flour, 75g of cocoa, 150g sugar and 150g of butter.
We can sell a chocolate cake for \$4.50 and a banana cake for \$4.00.  And we
have 4kg self-raising flour, 6 bananas, 2kg of sugar, 500g of butter and 500g
of cocoa.
The question is how many of each sort of cake should we bake for the fete to
maximise the profit.
A possible
\ZincOrMiniZinc model is shown in \autoref{ex:cakes}.

The first new feature is the use of \emph{arithmetic expressions}\index{expression!arithmetic}. 

\defblock{Integer Arithmetic Operators}{
\index{operator!integer}
\ZincOrMiniZinc provides the standard integer arithmetic operators.  
Addition (\texttt{+}\ttindexdefs{+}),
subtraction (\texttt{-}\ttindexdefs{-}),
multiplication (\texttt{*}\ttindexdefs{*}),
integer division (\texttt{div}\index{div@\texttt{div}|textbf}) 
and 
integer modulus (\texttt{mod}\index{mod@\texttt{mod}|textbf}). 
It also provides \texttt{+} and \texttt{-}
as unary operators. 

Integer modulus is defined to give a result $(a ~\texttt{mod}~ b)$
that has the same sign as the 
dividend $a$. Integer division is defined so that 
$\mathit{a} = \mathit{b} \texttt{*} (a ~\texttt{div}~ b) + (a ~\texttt{mod}~
b)$.

\ZincOrMiniZinc provides standard integer functions for 
absolute value (\texttt{abs}) and power function (\texttt{pow}).
For example \texttt{abs(-4)} and \texttt{pow(2,5)} evaluate to
$4$ and $32$ respectively.

The syntax for arithmetic literals is reasonably standard. Integer literals
can be decimal, hexadecimal or octal. For instance \texttt{0}, \texttt{5},
\texttt{123}, \texttt{0x1b7}, \texttt{0o777}.
}

The second new feature shown in the example is optimisation. The line
\begin{code}
solve maximize 400 * b + 450 * c;
\end{code}
specifies that we want to find a solution that maximises the expression in
the solve statement called the 
\emph{objective}\index{optimization}\index{objective}.  
The objective can be any
kind of arithmetic expression.  One can replace the key word 
\texttt{maximize}\ttindex{maximize}
by \texttt{minimize}\ttindex{minimize} to specify a minimisation problem.

\ignore{
Unfortunately our model will not run with the G12 implementation of \ZincOrMiniZinc
because this only supports constraints over integers and integer decision
variables. If we want a model that can run then we need to ``integerize''
the objective function and replace it with
\begin{code}
solve maximize 400*b + 450*c;
\end{code}
}

When we run this we obtain the result:
\begin{code}
no. of banana cakes = 2
no. of chocolate cakes = 2
----------
==========
\end{code}

{The line \texttt{==========}\index{solution!end \texttt{==========}}
\ttindexdefs{==========}
is output automatically for optimisation problems when the system has proved
that a solution is optimal.}


\subsection{Datafiles and Assertions}

A drawback of this model is that if we wish to solve a similar problem the
next time we need to bake cakes for the school (which is often) we need to
modify the constraints in the model to reflect the ingredients that we have
in the pantry. If we want to reuse the model then we would be better off to
make the amount of each ingredient a parameter of the model and then set
their values at the top of the model.

Even better would be to set the value of these parameters in a separate
\emph{data file}\index{data file}. 
\ZincOrMiniZinc (like most other modelling languages) allows the
use of data files to set the value of parameters declared in the original
model. This allows the same model to be easily used with different data by
running it with different data files.

Data files must have the file extension ``.dzn'' to indicate a \ZincOrMiniZinc data file
and a model can be run with any number of data files (though a variable/parameter can only be assigned a value in one file. 

\begin{figure}
\insertlitcode{cakes2}
\caption{Data-independent model for determining how many banana
  and chocolate cakes to bake for the school fete.\label{ex:cakes2}}
\end{figure}

\begin{litcode}{cakes2}{mzn}
% Baking cakes for the school fete (with data file)

int: flour;  %no. grams of flour available
int: banana; %no. of bananas available
int: sugar;  %no. grams of sugar available
int: butter; %no. grams of butter available
int: cocoa;  %no. grams of cocoa available

constraint assert(flour >= 0,"Invalid datafile: " ++
                  "Amount of flour should be non-negative");
constraint assert(banana >= 0,"Invalid datafile: " ++
                  "Amount of banana should be non-negative");
constraint assert(sugar >= 0,"Invalid datafile: " ++
                  "Amount of sugar should be non-negative");
constraint assert(butter >= 0,"Invalid datafile: " ++
                  "Amount of butter should be non-negative");
constraint assert(cocoa >= 0,"Invalid datafile: " ++
                  "Amount of cocoa should be non-negative");

var 0..100: b; % no. of banana cakes
var 0..100: c; % no. of chocolate cakes

% flour
constraint 250*b + 200*c <= flour;
% bananas
constraint 2*b  <= banana;
% sugar
constraint 75*b + 150*c <= sugar;
% butter
constraint 100*b + 150*c <= butter;
% cocoa
constraint 75*c <= cocoa;

% maximize our profit
solve maximize 400*b + 450*c;

output ["no. of banana cakes = \(b)\n",
        "no. of chocolate cakes = \(c)\n"];
\end{litcode}
       
Our new model is shown in \autoref{ex:cakes2}.
We can run it using the command
\begin{cmd}
$ mzn-g12fd cakes2.mzn pantry.dzn
\end{cmd} %$
where the data file \texttt{pantry.dzn} is defined in
\autoref{fig:pantry} gives the same result as \texttt{cakes.mzn}.
The output from running the command
\begin{cmd}
$ mzn-g12fd  cakes2.mzn pantry2.dzn
\end{cmd} %$
with an alternate data set defined in
\autoref{fig:pantry} the output is
\begin{cmd}
no. of banana cakes = 3
no. of chocolate cakes = 8
----------
==========
\end{cmd}

If we remove the output statement from \texttt{cakes.mzn} then
\ZincOrMiniZinc{} will use a default output. In this case the resulting
output  will be
\begin{cmd}
b = 3;
c = 8;
----------
==========
\end{cmd}

\defblock{Default Output}{
A \ZincOrMiniZinc{} model with no output will output a line for each
decision variable with its value, unless it is assigned an expression
on its declaration. Note how the output is in the form of a correct datafile.
}




\begin{figure}
\begin{tabular}{cc}
\begin{minipage}{0.45\textwidth}
\insertlitcode{pantry}
\begin{litcode}{pantry}{dzn}
flour = 4000; 
banana = 6; 
sugar = 2000; 
butter = 500; 
cocoa = 500;
\end{litcode} 
\end{minipage}
&
\begin{minipage}{0.45\textwidth}
\insertlitcode{pantry2}
\begin{litcode}{pantry2}{dzn}
flour = 8000; 
banana = 11; 
sugar = 3000; 
butter = 1500; 
cocoa = 800; 
\end{litcode}
\end{minipage}
\end{tabular}
\caption{Example data files for \texttt{cakes2.mzn}}\label{fig:pantry}
\end{figure}

Small data files can be entered 
without directly creating a \texttt{.dzn}
file, using the command line flag\index{data file!command line} 
\texttt{-D}\index{runtime flag!\texttt{-D}} \emph{string}, 
where \emph{string} is the contents of the data
file. For example the command % \char`
\begin{cmd}
$ mzn-g12fd cakes2.mzn -D \
     "flour=4000;banana=6;sugar=2000;butter=500;cocoa=500;"
\end{cmd} %$
will give identical results to \
\begin{cmd}
$ mzn-g12fd cakes2.mzn pantry.dzn
\end{cmd} %$

Data files can only contain assignment statements for 
decision variables and parameters in the model(s) for which they are intended. 

Defensive programming suggests that we should check that the values in the
data file are reasonable.  For our example it is sensible to check that the
quantity of all ingredients is non-negative and generate a run-time error if
this is not true. \ZincOrMiniZinc provides a built-in Boolean operator for checking
parameter values. The form is \emph{assert($B$,$S$)}\index{assert@\texttt{assert}}. The Boolean expression
$B$ is evaluated and if it is false execution aborts and the string
expression $S$ is evaluated and printed as an error message. To check and
generate an appropriate error message if the amount of flour is negative we
can simply add the line
\begin{code}
constraint assert(flour >= 0,"Amount of flour is non-negative");
\end{code}
to our model. Notice that the \emph{assert} expression is a Boolean
expression and so is regarded as a type of constraint. We can add similar
lines to check that the quantity of the other ingredients is non-negative.

\subsection{Real Number Solving}


\ZincOrMiniZinc also supports ``real number'' constraint solving using
floating point solving.  Consider a problem of taking out a short loan
for one year to be repaid in 4 quarterly instalments. 
A model for this is shown in \autoref{ex:loan}. It uses a simple interest
calculation to calculate the balance after each quarter.

\begin{figure}
\insertlitcode{loan}
\caption{Model for determining relationships between a 1 year loan
  repaying every quarter.\label{ex:loan}}
\begin{litcode}{loan}{mzn}
% variables
var float: R;        % quarterly repayment
var float: P;        % principal initially borrowed
var 0.0 .. 10.0: I;  % interest rate

% intermediate variables
var float: B1; % balance after one quarter
var float: B2; % balance after two quarters
var float: B3; % balance after three quarters
var float: B4; % balance owing at end

constraint B1 = P * (1.0 + I) - R;
constraint B2 = B1 * (1.0 + I) - R;
constraint B3 = B2 * (1.0 + I) - R; 
constraint B4 = B3 * (1.0 + I) - R;

solve satisfy;

output [
 "Borrowing ", show_float(0, 2, P), " at ", show(I*100.0), 
 "% interest, and repaying ", show_float(0, 2, R), 
  "\nper quarter for 1 year leaves ", show_float(0, 2, B4), " owing\n"
];
\end{litcode}
\end{figure}

Note that we declare a float variable $f$\index{variable!declaration}
similar to an integer variable using the keyword \texttt{float} instead of
\texttt{int}.

\ignore{
using \texttt{var float:}\index{var@\texttt{var}!float@\texttt{float}} $f$,
and we can declare a float variable $f$ in a fixed range $l$ to $u$ 
with a declaration of the form
\texttt{var} $l$ \texttt{..} $u$\texttt{:} $f$,\ttindexs{..}
\index{range!float}
where $l$ and $u$ are floating point expressions.
}
\defblock{Float Variable Declarations}{
A float parameter variable\index{variable!declaration!float} is declared as either:
\begin{quote}
  \texttt{\litkw{float}} \texttt{:} \qquote{\emph{var-name}} \\
  \qquote{\emph{l}} \texttt{..} \qquote{\emph{u}} \texttt{:} \qquote{\emph{var-name}}
\end{quote}
where \emph{l} and \emph{u} are fixed floating point expressions.

A float decision variable is declared
as either:\index{var@\texttt{var}!float@\texttt{float}|textbf}
\begin{quote}
  \texttt{\litkw{var}} \texttt{\litkw{float}} \texttt{:}
  \qquote{\emph{var-name}}  \\
  \texttt{\litkw{var}} \qquote{\emph{l}} \texttt{..} \qquote{\emph{u}} \texttt{:} \qquote{\emph{var-name}}
\end{quote}
where \emph{l} and \emph{u} are fixed floating point expressions.
}



We can use the same model to answer a number of different questions.
The first question is: if I borrow \$1000 at 4\% and repay \$260 per
quarter, how much do I end up owing? This question is encoded by
the data file \texttt{loan1.dzn}.

Since we wish to use real number solving we need to use a different
solver than the finite domain solver used by \texttt{mzn-g12fd}.
A suitable solver would be one that supports mixed integer linear
programming.
The MiniZinc distribution contains such a solver.
We can invoke it using the command \texttt{mzn-g12mip}
\begin{cmd}
$ mzn-g12mip loan.mzn loan1.dzn
\end{cmd} %$
The output is\\
\begin{cmd}
Borrowing 1000.00 at 4.0% interest, and repaying 260.00 
per quarter for 1 year leaves 65.78 owing 
----------
\end{cmd}

The second question is if I want to borrow \$1000 at 4\% and owe nothing at
the end, how much do I need to repay?
 This question is encoded by
the data file \texttt{loan2.dzn}.
The output from running the command\\
\begin{cmd}
$ mzn-g12mip loan.mzn loan2.dzn
\end{cmd} %$
is
\begin{cmd}
Borrowing 1000.00 at 4.0% interest, and repaying 275.49
per quarter for 1 year leaves 0.00 owing
----------
\end{cmd}

The third question is if I can repay \$250 a quarter, how much can I borrow
at 4\% to end up owing nothing? 
 This question is encoded by the data file \texttt{loan3.dzn}.
The output from running the command\\
\begin{cmd}
$ mzn-g12mip loan.mzn loan3.dzn
\end{cmd} %$
is
\begin{cmd}
Borrowing 907.47 at 4.0% interest, and repaying 250.00
per quarter for 1 year leaves 0.00 owing
----------
\end{cmd}

\begin{figure}
\begin{tabular}{ccc}
\begin{minipage}{0.3\textwidth}
\insertlitcode{loan1}
\end{minipage}
\begin{litcode}{loan1}{dzn}
I = 0.04;
P = 1000.0;
R = 260.0;
\end{litcode}
&
\begin{litcode}{loan2}{dzn}
I = 0.04;
P = 1000.0;
B4 = 0.0;
\end{litcode}
\begin{minipage}{0.3\textwidth}
\insertlitcode{loan2}
\end{minipage}
&
\begin{litcode}{loan3}{dzn}
I = 0.04;
R = 250.0;
B4 = 0.0;
\end{litcode}
\begin{minipage}{0.3\textwidth}
\insertlitcode{loan3}
\end{minipage}
\end{tabular}
\caption{Example data files for \texttt{loan.mzn}\label{fig:loan}}
\end{figure}

\defblock{Float Arithmetic Operators}{
\index{operator!float}
\ZincOrMiniZinc provides the standard floating point arithmetic operators:  
addition (\texttt{+}\ttindexs{+}), 
subtraction (\texttt{-}\ttindexs{-}),
multiplication (\texttt{*}\ttindexs{*}) 
and floating point division (\texttt{/}\ttindexdefs{/}). 
It also provides \texttt{+} and \texttt{-} as unary operators. 

\ZincOrMiniZinc does not automatically coerce integers to 
floating point numbers. The built-in function
\texttt{int2float}\index{int2float@\texttt{int2float}|textbf} 
can be used for this purpose.

\ZincOrMiniZinc provides in addition the following floating point functions: 
absolute value (\texttt{abs}\index{abs@\texttt{abs}|textbf}),
square root (\texttt{sqrt}\index{sqrt@\texttt{sqrt}|textbf}), 
natural logarithm (\texttt{ln}\index{ln@\texttt{ln}|textbf}),
logarithm base 2 (\texttt{log2}\index{log2@\texttt{log2}|textbf}), 
logarithm base 10 (\texttt{log10}\index{log10@\texttt{log10}|textbf}),
exponentiation of $e$ (\texttt{exp}\index{exp@\texttt{exp}|textbf}), 
sine (\texttt{sin}\index{sin@\texttt{sin}|textbf}), 
cosine (\texttt{cos}\index{cos@\texttt{cos}|textbf}), 
tangent (\texttt{tan}\index{tan@\texttt{tan}|textbf}),
arcsine (\texttt{asin}\index{asin@\texttt{asin}|textbf}), 
arc\-cosine (\texttt{acos}\index{acos@\texttt{acos}|textbf}), 
arctangent (\texttt{atan}\index{atan@\texttt{atan}|textbf}), 
hyperbolic sine (\texttt{sinh}\index{sinh@\texttt{sinh}|textbf}),
hyperbolic cosine (\texttt{cosh}\index{cosh@\texttt{cosh}|textbf}),
hyperbolic tangent (\texttt{tanh}\index{tanh@\texttt{tanh}|textbf}),
hyperbolic arcsine (\texttt{asinh}\index{asinh@\texttt{asinh}|textbf}),
hyperbolic arccosine (\texttt{acosh}\index{acosh@\texttt{acosh}|textbf}), 
hyperbolic arctangent (\texttt{atanh}\index{atanh@\texttt{atanh}|textbf}),
and power (\texttt{pow}\index{pow@\texttt{pow}|textbf}) which is the only binary function, the rest are
unary.

The syntax for arithmetic literals is reasonably standard. Example float literals are \texttt{1.05}, \texttt{1.3e-5} and \texttt{1.3E+5}.
}

\pjs{Should do multiple solutions????}
\subsection{Basic structure of a model}

We are now in a position to summarise the basic structure of a \ZincOrMiniZinc model.
It consists of multiple items each of which has a 
semicolon `\texttt{;}' at its end. 
Items can occur in any order.
For example, identifiers need not be declared before they are 
used. 

There are 8 kinds of items\index{item|textbf}.
\begin{itemize}
%\item[type definition]
\item 
\index{item!include}
Include items allow the contents of another file to be inserted into the model. They have the form:
\litblock{
\texttt{\litkw{include}} \qquote{\emph{filename}};
}
\index{include@\texttt{include}|textbf}
where \emph{filename} is a string literal.
They allow large models to be split into smaller sub-models and also the
inclusion of constraints defined in library files.
We shall see an example in \autoref{ex:smm}.

\item 
\index{item!variable declaration}
\index{variable!declaration}
Variable declarations declare new variables.
Such variables are global variables and can be referred to from anywhere in the
model.
Variables come in two kinds.
Parameters which are assigned a fixed value in the model or in a data file and
decision variables whose value is found only when the model is solved.
We say that parameters are \emph{fixed}\index{fixed} and decision variables
\emph{unfixed}\index{unfixed}.
The variable can be optionally assigned a value as part of the declaration.
The form is:
%\begin{quote}
%<\emph{type inst expr}> <\emph{variable}> [ \texttt{=} <\emph{expression}>];
%\end{quote}
\litblock{
  \qquote{\emph{type inst expr}}: \qquote{\emph{variable}} [ \texttt{=}
  \qquote{\emph{expression}}];
}
The \emph{type-inst expr}\index{expression!type-inst} 
gives the instantiation and type of the
variable. These are one of the more complex aspects of \ZincOrMiniZinc.
Instantiations are declared using \texttt{par}\index{par@\texttt{par}} 
for parameters and
\texttt{var}\index{var@\texttt{var}} for decision variables. If there is no explicit instantiation
declaration then the variable is a parameter.  
The type can be a base type,
an integer or float range\index{range} 
or an array or a set.
The base types are \texttt{float}\index{float@\texttt{float}},
\texttt{int}\index{int@\texttt{int}}, 
\texttt{string}\index{string@\texttt{string}}, 
\texttt{bool}\index{bool@\texttt{bool}},
\texttt{ann}\index{ann@\texttt{ann}} 
of which only
\texttt{float}, \texttt{int} and \texttt{bool} can be used for decision
variables. 
The base type \texttt{ann} is an annotation\index{annotation}%
---we shall discuss
annotations in \autoref{sec:search}.
Integer range expressions\index{range!integer} can be used
instead of the type \texttt{int}. 
Similarly float range expressions\index{range!float} 
can be used instead of type \texttt{float}.
These are typically used to give the
domain of an integer decision variable but can also be used to restrict the
range of an integer parameter. Another use of variable declarations is to
define enumerated types\index{enumerated types}---which we discuss in \autoref{sec:enum}.

\item 
\index{assignment}
\index{item!assignment}
Assignment items assign a value to a variable. They have the form:
\litblock{
 \qquote{\emph{variable}} \texttt{=}  \qquote{\emph{expression}};
}
Values can be assigned to decision variables in which case the assignment is
equivalent to writing \texttt{constraint} \qquote{\emph{variable}}
\texttt{=}\index{=@\texttt{=}} 
\qquote{\emph{expression}};

\item 
\index{constraint}
\index{item!constraint}
Constraint items form the heart of the model. They have the form:
\litblock{
  \texttt{\litkw{constraint}} \qquote{\emph{Boolean expression}};
}
\index{constraint@\texttt{constraint}|textbf}
We have already seen examples of simple constraints using arithmetic
comparison and the built-in \emph{assert} operator. In the next section we
shall see examples of more complex constraints.

\item 
\index{item!solve}
Solve items specify exactly what kind of solution is being looked for.
As we have seen they have one of three forms:
\litblock{
\texttt{\litkw{solve satisfy}}\texttt{;} \\
\texttt{\litkw{solve maximize}}  \qquote{\emph{arithmetic expression}}\texttt{;}\\
\texttt{\litkw{solve minimize}}  \qquote{\emph{arithmetic expression}}\texttt{;}
}
\index{satisfy@\texttt{satisfy}|textbf}
\index{maximize@\texttt{maximize}|textbf}
\index{minimize@\texttt{minimize}|textbf}
A model is required to have exactly one solve item.

\item 
\index{output}
\index{item!output}
Output items are for nicely presenting the results of the model execution. 
They have the form:
\litblock{
\texttt{\litkw{output}}  \texttt{[} \qquote{\emph{string expression}}\texttt{,} $\cdots$ \texttt{,}  \qquote{\emph{string expression}} \texttt{]}\texttt{;}
}
\index{output@\texttt{output}}

If there is no output item, MiniZinc will by default print out the values of
all the decision variables which are not optionally assigned a value in the
format of assignment items.

\item
  \index{item!enum}
  Enumerated type declarations.
  We discuss these in \autoref{sec:arrayset} and \autoref{sec:enum}.
\item 
\index{item!predicate}
Predicate function and test items are for defining new constraints, 
functions and Boolean tests.
We discuss these in \autoref{sec:predicates}.
\item 
\index{item!annotation}
The annotation item is used to define a new annotation. We 
discuss these in \autoref{sec:search}.

\end{itemize}
