\newpage

\section{Search}\label{sec:search}

By default in \ZincOrMiniZinc there is no declaration of how
we want to search for solutions. This leaves the search
completely up to the underlying solver.
But sometimes, particularly for combinatorial integer problems,
we may want to specify how the search should be undertaken.
This requires us to communicate to the solver a search strategy\index{search}.
Note that the search strategy is \emph{not} really part
of the model.
Indeed it is not required that each solver implements all
possible search strategies.
\ZincOrMiniZinc uses a consistent approach to communicating extra information
to the constraint solver using \emph{annotations}\index{annotation}.

\subsection{Finite Domain Search}

\index{search!finite domain}
Search in a finite domain solver involves examining the
remaining possible values of variables and choosing to
constrain some variables further.
The search then adds a new constraint that
restricts the remaining values
of the variable
(in effect guessing where the solution might lie),
and then applies propagation to determine what other values
are still possible in solutions.
In order to guarantee completeness, the search leaves another
choice which is the negation of the new constraint.
The search ends either when
the finite domain solver detects that all constraints are satisfied,
and hence a solution has been found, or that the constraints are
unsatisfiable.
When unsatisfiability is detected
the search must proceed down a different set of
choices.  Typically finite domain solvers use \emph{depth first
  search}\index{search!depth first}
where they undo the last choice made and then try to make a new choice.

\begin{figure}[h]
\insertlitcode{nqueens}
\begin{litcode}{nqueens}{mzn}
int: n;
array [1..n] of var 1..n: q; % queen is column i is in row q[i]

include "alldifferent.mzn";

constraint alldifferent(q);                       % distinct rows
constraint alldifferent([ q[i] + i | i in 1..n]); % distinct diagonals
constraint alldifferent([ q[i] - i | i in 1..n]); % upwards+downwards

\begin{litblock}{search}
solve :: int_search(q, first_fail, indomain_min, complete)
      satisfy;
\end{litblock}
output [ if fix(q[j]) == i then "Q" else "." endif ++
         if j == n then "\n" else "" endif | i,j in 1..n]
\end{litcode}
\caption{Model for $n$-queens
  (\texttt{nqueens.mzn}).\label{ex:queens}}
\end{figure}

A simple example of a finite domain problem is the $n$ queens
problem which requires that we
place $n$ queens on an $n \times n$ chessboard so that none can
attack another.
The variable $q[i]$ records in which row the queen in column $i$
is placed. The \talldiff{} constraints ensure
that no two queens are on the same row, or diagonal.
A typical (partial) search tree
for $n = 9$ is illustrated in the left of \autoref{fig:9q}.
We first set $q[1] = 1$, this removes values from the domains of other
variables, so that e.g. $q[2]$ cannot take the values 1 or 2.
We then set $q[2] = 3$, this further removes values from the domains
of other variables. We set $q[3] = 5$ (its earliest possible value).
The state of the chess board after these three decisions is shown in
\autoref{fig:9q}(a) where the queens indicate the position
of the queens fixed already and
the stars indicate positions where we cannot place a queen
since it would be able to take an already placed queen.

\begin{figure}
\begin{minipage}{0.45\textwidth}
\includegraphics[width=\textwidth]{figures/tree-4}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{tabular}{c}
\includegraphics[width=\textwidth]{figures/chess9x9-3} \\
(a) \\
\includegraphics[width=\textwidth]{figures/chess9x9-4} \\
(b) \\
\end{tabular}
\end{minipage}
\caption{Partial search trees for 9 queens: (a) the state
after the addition of
$q[1] = 1$, $q[2] = 4$, $q[3] = 5$ (b) the
initial propagation on adding further $q[6] = 4$.
}
\label{fig:9q}
\end{figure}

A search strategy determines which choices to make. The decisions we have
made so far follow the simple strategy of picking the
first variable which is not fixed yet, and try to set it to its least
possible value.  Following this strategy the next decision would be
$q[4] = 7$.
An alternate strategy for variable selection is to choose the variable whose
current set of possible values (\emph{domain}) is smallest.
Under this so called \emph{first-fail}
variable selection strategy the next decision would be
$q[6] = 4$.
If we make this decision, then initially propagation removes the additional
values shown in \autoref{fig:9q}(b). But this leaves only one value for
$q[8]$, $q[8] = 7$, so this is forced, but then this leaves only one
possible value for $q[7]$ and $q[9]$, that is 2. Hence a constraint must be
violated. We have detected unsatisfiability, and the solver must backtrack
undoing the last decision $q[6] = 4$ and adding its negation $q[6] \neq 4$
(leading us to state (c) in the tree in \autoref{fig:9q})
which forces $q[6] = 8$. This removes some values from the domain
and then we again reinvoke the search strategy to decide what to do.

Many finite domain searches are defined in this way:
choose a variable to constrain further, and then choose how to
constrain it further.

\subsection{Search Annotations}

\index{search!annotation}
Search annotations in \ZincOrMiniZinc
specify how to search in order to find a solution to the
problem. The annotation is attached to the solve item, after the keyword
\texttt{solve}\ttindex{solve}.
The search annotation
\insertlitcode{nqueens:search}
appears on the solve item. Annotations are attached to parts of
the model using the connector \texttt{::}\ttindex{::}.
This search annotation means that we should search by selecting from
the array of integer variables \texttt{q}, the variable with the smallest
current domain (this is the \texttt{first\_fail}\index{search!variable choice!\texttt{first\_fail}} rule), and try setting
it to its smallest possible value
(\texttt{indomain\_min}\index{search!constrain choice!\texttt{indomain\_min}} 
value selection), looking across the entire search tree
(\texttt{complete}\index{search!\texttt{complete}} search).



% \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
% \hline
% Q & . & . & . & . & . & . & . & . \\ \hline
% . & . & . &   &   & . &   &   &   \\ \hline
% . & Q & . & . & . & . & . & . & . \\ \hline
% . & . & . & . &   &   &   &   &   \\ \hline
% . & . & Q & . & . & . & . & . & . \\ \hline
% . & . & . & . & . & . &   &   &   \\ \hline
% . & . & . &   & . & . & . &   &   \\ \hline
% . & . & . &   &   & . & . & . &   \\ \hline
% . & . & . &   &   &   & . & . & . \\ \hline
% \end{tabular}

\defblock{Basic search annotations}{
There are three basic search annotations corresponding to different
basic variable types:
\begin{itemize}
\item \texttt{int\_search(\emph{variables}, \emph{varchoice},
  \emph{constrainchoice}, \emph{strategy})}
\ttindexdef{int\_search}
where \emph{variables} is an one dimensional array of \texttt{var int},
\emph{varchoice} is a variable choice annotation discusses below,
\emph{constrainchoice} is a choice of how to constrain a variable, discussed
below, and \emph{strategy} is a search strategy which we will assume for now
is \texttt{complete}.
\item \texttt{bool\_search(\emph{variables}, \emph{varchoice},
  \emph{constrainchoice}, \emph{strategy})}
\ttindexdef{bool\_search}
where \emph{variables} is an one dimensional array of \texttt{var bool}
and the rest are as above.
\item \texttt{set\_search(\emph{variables}, \emph{varchoice},
  \emph{constrainchoice}, \emph{strategy})}
\ttindexdef{set\_search}
where \emph{variables} is an one dimensional array of \texttt{var set
of int}
and the rest are as above.
\end{itemize}
Example variable choice annotations are:
\index{search!variable choice}
\texttt{input\_order}\ttindexdef{input\_order}\index{search!variable choice!\texttt{input\_order}} choose in order from the array,
\texttt{first\_fail}\ttindexdef{first\_fail}\index{search!variable choice!\texttt{first\_fail}} choose the variable with the smallest domain size, and
\texttt{smallest}\ttindexdef{smallest}\index{search!variable choice!\texttt{smallest}} choose the variable with the smallest value in its domain.

Example ways to constraint a variable are:
\index{search!constrain choice}
\texttt{indomain\_min}\ttindexdef{indomain\_min}\index{search!constrain choice!\texttt{indomain\_min}}
 assign the variable its smallest domain value,
\texttt{indomain\_median}\ttindexdef{indomain\_median}\index{search!constrain choice!\texttt{indomain\_median}} assign the variable its median domain value,
\texttt{indomain\_random}\ttindexdef{indomain\_random}\index{search!constrain choice!\texttt{indomain\_random}} assign the variable a random value from its
domain, and
\texttt{indomain\_split}\ttindexdef{indomain\_split}\index{search!constrain choice!\texttt{indomain\_split}} bisect the variables domain excluding the upper half.

Strategy is almost always \texttt{complete} for complete search.
For a complete list of variable and constraint choice annotations
see the FlatZinc specification in the \ZincOrMiniZinc reference
documentation.
}
\pjs{float\_search??}

We can construct more complex search strategies using search
constructor annotations. There is only one such annotation at present.
\litblock{\tt
seq\_search([ \emph{search\_ann}, \ldots, \emph{search\_ann} ])
}
\ttindexdef{seq\_search}
\index{search!sequential}
The sequential search constructor first undertakes the search given
by the first annotation in its list, when all variables in this annotation
are fixed it undertakes the second search annotation, etc until all
search annotations are complete.

Consider the jobshop scheduling model shown in \autoref{ex:jobshop3}.
We could replace the solve item with
\begin{code}
solve :: seq_search([
             int_search(s, smallest, indomain_min, complete),
             int_search([end], input_order, indomain_min, complete)])
      minimize end
\end{code}
which tries to set start times \texttt{s} by choosing the job that can start
earliest and setting it to that time. When all start times are complete
the end time \texttt{end} may not be fixed. Hence we set it to
its minimal possible value.


\subsection{Annotations}

\index{annotation}
Annotations are a first class object in \ZincOrMiniZinc. We
can declare new annotations in a model, and declare and assign
to annotation variables.

\defblock{Annotations}{
\index{annotation|textbf}
Annotations have a type \texttt{ann}\ttindexdef{ann}. 
You can declare an annotation
parameter\index{parameter} (with optional assignment)
\litblock{
\texttt{\litkw{ann}} \texttt{:} \qquote{ident} [ \texttt{=} \qquote{ann-expr} ] \texttt{;}
}
and assign to an annotation variable just as any other parameter.

Expressions\index{expression}, variable 
declarations\index{variable!declaration}, and \texttt{solve}\ttindex{solve} 
items can all
be annotated using the \texttt{::}\ttindex{::} operator.


We can declare a new annotation\ttindexdef{annotation} 
using the annotation item\index{item!annotation}
\litblock{
\texttt{\litkw{annotation}} \qquote{annotation-name}( \qquote{arg-def}, \ldots,
\qquote{arg-def} ) \texttt{;}
}
}

\begin{figure}
\insertlitcode{nqueens-ann}
\begin{litcode}{nqueens-ann}{mzn}
annotation bitdomain(int:nwords);

include "alldifferent.mzn";

int: n;
array [1..n] of var 1..n: q :: bitdomain(n div 32);

constraint alldifferent(q) :: domain;                      
constraint alldifferent([ q[i] + i | i in 1..n]) :: domain;
constraint alldifferent([ q[i] - i | i in 1..n]) :: domain;

ann: search_ann;

solve :: search_ann satisfy;

output [ if fix(q[j]) == i then "Q" else "." endif ++
         if j == n then "\n" else "" endif | i,j in 1..n]
\end{litcode}
\caption{Annotated model for $n$-queens
  (\texttt{nqueens-ann.mzn}).\label{ex:queens-ann}}
\end{figure}

The program in \autoref{ex:queens-ann} illustrates the use of annotation
declarations, annotations and annotation variables.
We declare a new annotation \texttt{bitdomain} which is meant to tell
the solver that variables domains should be represented via bit arrays
of size \texttt{nwords}.
The annotation is attached to the declarations of the variables \texttt{q}.
Each of the \talldiff{} constraints is annotated with
the built in annotation \texttt{domain}\ttindex{domain} 
which instructs the solver to use
the domain propagating version of \talldiff{} if it has one.
An annotation variable \texttt{search\_ann} is declared and used
to define the search strategy.  We can give the value to the search
strategy in a separate data file.

Example search annotations might be the following (where
we imagine each line is in a separate data file)
\begin{code}
search_ann = int_search(q, input_order, indomain_min, complete);
search_ann = int_search(q, input_order, indomain_median, complete);
search_ann = int_search(q, first_fail, indomain_min, complete);
search_ann = int_search(q, first_fail, indomain_median, complete);
\end{code}
The first just tries the queens in order setting them to the
minimum value, the second tries the queens variables in order, but sets
them to their median value, the third tries the queen variable with smallest
domain and sets it to the minimum value, and the final strategy
tries the queens variable with smallest domain setting it to its median
value.

Different search strategies can make a significant difference in
how easy it is to find solutions.
A small comparison of the number of choices made to find the first solution
of the n-queens problems using the 4 different search strategies
is shown in the table below (where --- means more than 100,000 choices).
Clearly the right search strategy can make a significant difference.
\begin{center}
\begin{tabular}{l|rrrr}
$n$ & input-min & input-median & ff-min & ff-median \\
\hline
10 & 28 & 15 & 16 & 20 \\
15 & 248 & 34 & 23 & 15 \\
20 & 37330 & 97 & 114 & 43 \\
25 & 7271 & 846 & 2637 & 80 \\
30 & --- & 385 & 1095 & 639 \\
35 & --- & 4831 & --- & 240 \\
40 & --- & --- & --- & 236 \\
\end{tabular}
\end{center}


\ifthenelse {\boolean{UseZinc}}
{
\include{search_zinc}
}
{
% MiniZinc
}
