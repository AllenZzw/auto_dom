
\newpage

\section{Predicates and Functions}
\index{function}
\index{predicate}
\label{sec:predicates}

Predicates in \ZincOrMiniZinc 
allow us to capture complex constraints of our model
in a succinct way.  Predicates in \ZincOrMiniZinc 
are used to model with both predefined global
constraints, and to capture and define new complex constraints by the
modeller.
Functions are used in \ZincOrMiniZinc to capture common structures of models.
Indeed a predicate is just a function with output type \texttt{var bool}.
\index{\texttt{var}!\texttt{bool}}

\subsection{Global Constraints}\label{sec:globals}

\index{global constraint|textbf}
There are many global constraints defined in \ZincOrMiniZinc for use in modelling.
The definitive list is to be found in the documentation for the release, as
the list is slowly growing.  
Below we discuss some of the most important global constraints


\subsubsection{Alldifferent}
\ttindexdef{alldifferent}
\index{global constraint!\texttt{alldifferent}|textbf}

The \talldiff{} constraint takes an array of variables and constrains them
to take different values.
A use of the \talldiff{} has the form
\begin{code}
alldifferent(array[int] of var int: x)
\end{code}
that is the argument is array of integer variables.

Alldifferent is one of the most studied and used global constraints in
constraint programming.  It is used to define assignment subproblems, and
efficient global propagators for \talldiff{} exist. %~\cite{regin}.
\texttt{send-more-money.mzn} (\autoref{ex:smm})
and \texttt{sudoku.mzn} (\autoref{ex:sudoku})
are examples of models using \talldiff{}.

\subsubsection{Cumulative}
\ttindexdef{cumulative}
\index{global constraint!\texttt{cumulative}|textbf}

The \texttt{cumulative} constraint is used for describing cumulative resource
usage. 
\begin{code}
cumulative(array[int] of var int: s, array[int] of var int: d, 
           array[int] of var int: r, var int: b)
\end{code}
Requires that a set of tasks given by start times $s$, durations $d$, 
and resource requirements $r$, never require more 
than a global resource bound $b$ at any one time.

\begin{figure}
\insertlitcode{moving}
\begin{litcode}{moving}{mzn}
include "cumulative.mzn";

enum OBJECTS;
array[OBJECTS] of int: duration; % duration to move
array[OBJECTS] of int: handlers; % number of handlers required
array[OBJECTS] of int: trolleys; % number of trolleys required

int: available_handlers;
int: available_trolleys;
int: available_time;

array[OBJECTS] of var 0..available_time: start;
var 0..available_time: end;

constraint cumulative(start, duration, handlers, available_handlers);
constraint cumulative(start, duration, trolleys, available_trolleys);
 
constraint forall(o in OBJECTS)(start[o] +duration[o] <= end);

solve minimize end;

output [ "start = \(start)\nend = \(end)\n"];
\end{litcode}
\caption{Model for moving furniture using \texttt{cumulative}
(\texttt{moving.mzn}).\label{ex:moving}}
\end{figure}

\begin{figure}
\insertlitcode{moving.dzn}
\begin{litcode}{moving.dzn}{}
OBJECTS = { piano, fridge, doublebed, singlebed, 
            wardrobe, chair1, chair2, table };

duration = [60, 45, 30, 30, 20, 15, 15, 15];
handlers = [3, 2, 2, 1, 2, 1, 1, 2];
trolleys = [2, 1, 2, 2, 2, 0, 0, 1];

available_time = 180;
available_handlers = 4;
available_trolleys = 3;
\end{litcode}  
\caption{Data for moving furniture using \texttt{cumulative}
(\texttt{moving.dzn}).\label{ex:movingd}}
\end{figure}

The model in \autoref{ex:moving} finds a schedule for moving furniture
so that each piece of furniture has enough handlers (people) and enough trolleys
available during the move. The available time, handlers 
and trolleys are given, and the data gives for each object the move
duration,
the number of handlers and the number of trolleys required. 
Using the data shown in \autoref{ex:movingd}, the command
\begin{cmd}
$ mzn-g12fd moving.mzn moving.dzn
\end{cmd} %$
may result in the output
\begin{cmd}
start = [0, 60, 60, 90, 120, 0, 15, 105]
end = 140
----------
==========
\end{cmd}
\autoref{fig:histogram}(a) and \autoref{fig:histogram}(b) 
show the requirements for handlers and
trolleys at each time in the move for this solution.
\begin{figure}
\begin{center}
\begin{tabular}{cc}
\raisebox{1cm}{(a)} & 
\includegraphics[width=8cm]{figures/handlers}
\\
\raisebox{1cm}{(b)} & \includegraphics[width=8cm]{figures/trolleys}
\end{tabular}
\end{center}
\caption{Histograms of usage of (a) handlers and (b) trolleys in the move.}
\label{fig:histogram}
\end{figure}

\subsubsection{Table}
\ttindexdef{table}
\index{global constraint!\texttt{table}|textbf}

The \texttt{table} constraint enforces that the tuple of variables
takes a value from a set of tuples. Since there are no tuples in \ZincOrMiniZinc
this is encoded using arrays. The usage of \texttt{table}
has one of the forms
\begin{code}
table(array[int] of var bool: x, array[int, int] of bool: t)
table(array[int] of var int:  x, array[int, int] of int:  t)
\end{code}
depending on whether the tuples are Boolean or integer.
The constraint enforces $x \in t$ where we consider $x$
and each row in $t$ to be a tuple,
and $t$ to be a set of tuples.

\begin{figure}
\insertlitcode{meal}
\begin{litcode}{meal}{mzn}
% Planning a balanced meal
include "table.mzn";
int: min_energy;
int: min_protein;
int: max_salt;
int: max_fat;
set of FOOD: desserts;
set of FOOD: mains;
set of FOOD: sides;
enum FEATURE = { name, energy, protein, salt, fat, cost}; 
enum FOOD; 
array[FOOD,FEATURE] of int: dd; % food database

array[FEATURE] of var int: main;
array[FEATURE] of var int: side;
array[FEATURE] of var int: dessert;
var int: budget;

constraint main[name] in mains;
constraint side[name] in sides;
constraint dessert[name] in desserts;
constraint table(main, dd);
constraint table(side, dd);
constraint table(dessert, dd);
constraint main[energy] + side[energy] + dessert[energy] >=min_energy;
constraint main[protein]+side[protein]+dessert[protein] >=min_protein;
constraint main[salt] + side[salt] + dessert[salt] <= max_salt;
constraint main[fat] + side[fat] + dessert[fat] <= max_fat;
constraint budget = main[cost] + side[cost] + dessert[cost];

solve minimize budget; 

output ["main = ",show(to_enum(FOOD,main[name])),", 
        ", side = ",show(to_enum(FOOD,side[name])),
        ", dessert = ",show(to_enum(FOOD,dessert[name]))],
        ", cost = ",show(budget), "\n"];
\end{litcode}
\caption{Model for meal planning using \texttt{table} constraint 
(\texttt{meal.mzn}).\label{ex:meal}}
\end{figure}

\begin{figure}
\insertlitcode{meal.dzn}
\begin{litcode}{meal.dzn}{}
FOODS = { icecream, banana, chocolatecake, lasagna, 
          steak, rice, chips, brocolli, beans} ;

dd = [| icecream,      1200,  50,  10, 120,  400     % icecream
      | banana,         800, 120,   5,  20,  120     % banana
      | chocolatecake, 2500, 400,  20, 100,  600     % chocolate cake
      | lasagna,       3000, 200, 100, 250,  450     % lasagna
      | steak,         1800, 800,  50, 100, 1200     % steak
      | rice,          1200,  50,   5,  20,  100     % rice
      | chips,         2000,  50, 200, 200,  250     % chips
      | brocolli,       700, 100,  10,  10,  125     % brocolli
      | beans,         1900, 250,  60,  90,  150 |]; % beans

min_energy = 3300;
min_protein = 500;
max_salt = 180;
max_fat = 320;
desserts = { icecream, banana, chocolotecake };
mains = { lasagna, steak, rice };
sides = { chips, brocolli, beans };
\end{litcode}
\caption{Data for meal planning defining the \texttt{table} used 
(\texttt{meal.dzn}).\label{ex:meald}}
\end{figure}

The model in \autoref{ex:meal} searches for balanced meals.
Each meal item has a name (encoded as an integer), a kilojoule count,
protein in grams, salt in milligrams, and fat in grams, as well as cost
in cents.  The relationship between these items is encoded using
a \texttt{table} constraint.
The model searches for a minimal cost meal 
which has a minimum kilojoule count
$min\_energy$, a minimum amount of protein $min\_protein$,
maximum amount of salt $max\_salt$ and fat $max\_fat$.

\subsubsection{Regular}
\ttindexdef{regular}
\index{global constraint!\texttt{regular}|textbf}

The \texttt{regular} constraint is used to enforce that a sequence of
variables takes a value defined by a finite automaton.
The usage of \texttt{regular} has the form
\begin{code}
regular(array[int] of var int: x, int: Q, int: S,
        array[int,int] of int: d, int: q0, set of int: F)
\end{code}
It constrains that 
the sequence of values in array $x$ (which must all be in the range
$\range{1}{S}$)\index{range} 
is accepted by the DFA\index{DFA} of $Q$ states with input $\range{1}{S}$ 
and transition function $d$ (which maps $<\range{1}{Q}, \range{1}{S}>$ to 
$\range{0}{Q}$) and initial state
$q0$ (which must be in $\range{1}{Q}$) and accepting states $F$ 
(which all must be in $\range{1}{Q}$). 
State 0 is reserved to be an always failing state. 

\begin{figure}
$$
\newcommand{\xyo}[1]{*+++[o][F-]{#1}}    
\newcommand{\xyd}[1]{*+[F=]{#1}}    
\xymatrix@R=8mm@C=12mm{
   \ar[r]   &\xyo{1} \ar[r]^d \ar[dr]^n \ar@(ur,ul)[]_o & 
             \xyo{2} \ar[r]^{\{d,n\}} \ar@/_5mm/[l]_(0.3)o &
      \xyo{4} \ar[r]^{\{d,n\}}\ar@/_8mm/[ll]^o  & \xyo{6}\ar@/_12mm/[lll]^o \\
      & & \xyo{3} \ar[ur]^d \ar[r]^n \ar@/^5mm/[ul]_o 
      & \xyo{5} \ar[ur]^{d} \ar@/^15mm/[ull]_o
}
$$
\caption{A DFA determining correct rosters.\label{fig:dfa}}
\end{figure} 

Consider a nurse rostering problem. Each nurse is scheduled for each day as
either: (d) on day shift, (n) on night shift, or (o) off.
In each four day period a nurse must have at least one day off, and
no nurse can be scheduled for 3 night shifts in a row.
This can be encoded using the incomplete DFA shown in \autoref{fig:dfa}.
We can encode this DFA as having start state 1, final states \range{1}{6},
and transition function 
% $$
% \begin{array}{l|rrrrrr} 
%   & 1 & 2 & 3 & 4 & 5 & 6  \\ \hline
% d & 2 & 4 & 4 & 6 & 6 & 0  \\
% n & 3 & 4 & 5 & 6 & 0 & 0  \\
% o & 1 & 1 & 1 & 1 & 1 & 1 
% \end{array}
% $$
$$
\begin{array}{l|rrr} 
  & d & n & o \\ \hline 
1 & 2 & 3 & 1 \\
2 & 4 & 4 & 1 \\
3 & 4 & 5 & 1 \\
4 & 6 & 6 & 1 \\
5 & 6 & 0 & 1 \\
6 & 0 & 0 & 1 
\end{array}
$$
Note that state 0 in the table indicates an error state.
The model shown in \autoref{ex:nurse} finds a schedule for
$num\_nurses$ nurses over $num\_days$ days, where we
require $req\_day$ nurses on day shift each day, and 
$req\_night$ nurses on night shift, and that each nurse
takes at least $min\_night$ night shifts.

\begin{figure}
\insertlitcode{nurse}
\begin{litcode}{nurse}{mzn}
% Simple nurse rostering
include "regular.mzn";
enum NURSE;
enum DAY;
int: req_day;
int: req_night;
int: min_night;

enum SHIFT = { d, n, o };
int: S = card(SHIFT);

int: Q = 6; int: q0 = 1; set of int: STATE = 1..Q;
array[STATE,SHIFT] of int: t =
     [| 2, 3, 1    % state 1
      | 4, 4, 1    % state 2
      | 4, 5, 1    % state 3
      | 6, 6, 1    % state 4
      | 6, 0, 1    % state 5
      | 0, 0, 1|]; % state 6 

array[NURSE,DAY] of var SHIFT: roster;

constraint forall(j in DAY)(
             sum(i in NURSE)(roster[i,j] == d) == req_day /\
             sum(i in NURSE)(roster[i,j] == n) == req_night
           );
constraint forall(i in NURSE)(
             regular([roster[i,j] | j in DAY], Q, S, t, q0, STATE) /\
             sum(j in DAY)(roster[i,j] == n) >= min_night
           );

solve satisfy;

output [ show(roster[i,j]) ++ if j==card(DAY) then "\n" else " " endif
       | i in NURSE, j in DAY ]; 
\end{litcode}
\caption{Model for nurse rostering using \texttt{regular} constraint 
(\texttt{nurse.mzn}).\label{ex:nurse}}
\end{figure}

Running the command
\begin{cmd}
$ mzn-g12fd nurse.mzn nurse.dzn
\end{cmd} %$
finds a 10 day schedule for 7 nurses, requiring 3 on each day shift
and 2 on each night shift, with a minimum 2 night shifts per nurse.
A possible output is
\begin{cmd}
o d n n o n n d o o
d o n d o d n n o n
o d d o d o d n n o
d d d o n n d o n n
d o d n n o d o d d
n n o d d d o d d d
n n o d d d o d d d
----------
\end{cmd}

There is an alternate form of the regular constraint
\texttt{regular\_nfa}\ttindexdef{regular\_nfa} which specifies the regular
expression using and NFA (without $\epsilon$ arcs).
This constraint has the form
\begin{code}
regular_nfa(array[int] of var int: x, int: Q, int: S,
        array[int,int] of set of int: d, int: q0, set of int: F)
\end{code}
It constrains that 
the sequence of values in array $x$ (which must all be in the range
$\range{1}{S}$)\index{range} 
is accepted by the NFA\index{NFA} of $Q$ states with input $\range{1}{S}$ 
and transition function $d$ (which maps $<\range{1}{Q}, \range{1}{S}>$ to 
subsets of $\range{1}{Q}$) and initial state
$q0$ (which must be in $\range{1}{Q}$) and accepting states $F$ 
(which all must be in $\range{1}{Q}$). 
There is no need for a failing state 0, since the transition function can
map to an empty set of states. 


\subsection{Defining Predicates}

\index{predicate!definition}
One of the most powerful modelling features 
of \ZincOrMiniZinc is the ability for
the modeller to define their own high-level constraints. This allows them to
abstract and modularise their model. It also allows re-use of constraints in
different models and allows the development of application specific
libraries defining the standard constraints and types.

\begin{figure}
\insertlitcode{jobshop2}
\begin{litcode}{jobshop2}{mzn}
int: jobs;                                    % no of jobs
set of int: JOB = 1..jobs;
int: tasks;                                   % no of tasks per job
set of int: TASK = 1..tasks;
array [JOB,TASK] of int: d;                   % task durations
int: total = sum(i in JOB, j in TASK)(d[i,j]);% total duration
int: digs = ceil(log(10.0,total));            % digits for output
array [JOB,TASK] of var 0..total: s;          % start times
var 0..total: end;                            % total end time

\begin{litblock}{nooverlap}
predicate no_overlap(var int:s1, int:d1, var int:s2, int:d2) =
    s1 + d1 <= s2 \/ s2 + d2 <= s1;
\end{litblock}

constraint %% ensure the tasks occur in sequence
    forall(i in JOB) (
        forall(j in 1..tasks-1) 
            (s[i,j] + d[i,j] <= s[i,j+1]) /\
        s[i,tasks] + d[i,tasks] <= end
    );

constraint %% ensure no overlap of tasks
    forall(j in TASK) (
        forall(i,k in JOB where i < k) (
            no_overlap(s[i,j], d[i,j], s[k,j], d[k,j])
        )
    );

solve minimize end;

output ["end = \(end)\n"] ++
       [ show_int(digs,s[i,j]) ++ " " ++ 
         if j == tasks then "\n" else "" endif |
         i in JOB, j in TASK ];
\end{litcode}
\caption{Model for job shop scheduling using predicates 
(\texttt{jobshop2.mzn}).\label{ex:job-shop}}
\end{figure}

We start with a simple example, revisiting the job shop scheduling problem
from the previous section.  The model is shown in
\autoref{ex:job-shop}. The item of interest is the 
\texttt{predicate}\ttindex{predicate}\index{item!predicate}
item:
\insertlitcode{jobshop2:nooverlap}

This defines a new constraint that enforces that a task with start time
\texttt{s1} and duration \texttt{d1} does not overlap with a task with start
time \texttt{s2} and duration \texttt{d2}.  This can now be used inside the
model anywhere any other Boolean expression\index{expression!Boolean} 
(involving decision variables)
can be used.

As well as predicates the modeller can define new constraints that only
involve parameters. Unlike predicates these can be used inside the test of a
conditional expression. These are defined using the keyword 
\texttt{test}\ttindex{test}.
For example
\begin{code}
test even(int:x) = x mod 2 = 0;
\end{code}

\ignore{ % for capture for testing!
$ mzn-g12fd jobshop2.mzn jobshop.dzn
} % $

\clearpage
\newpage

\defblock{Predicate definitions}{
\index{predicate!definition|textbf}
Predicates are defined by a statement of the form
\litblock{
\texttt{\litkw{predicate}} \qquote{pred-name} \texttt{(} \qquote{arg-def}, \ldots,
\qquote{arg-def} \texttt{)} \texttt{=} 
\qquote{bool-exp} 
}
\ttindexdef{predicate}
The \qquote{pred-name} must be a valid \ZincOrMiniZinc identifier, and
each \qquote{arg-def} is a valid \ZincOrMiniZinc type\index{type} declaration.

\ignore{The type-insts\index{type-inst} 
of arguments may include type-inst variables\index{type-inst!variable} 
which are of the
form \texttt{\$T} or \texttt{any \$T} with \texttt{T} an identifier. A type-inst
variable \texttt{\$T}\ttindexdef{\$T} 
can match any fixed type-inst, whereas a type-inst
variable \texttt{any \$T} can 
also match non-fixed type-insts\index{type-index!non-fixed} 
(such as \texttt{var int}).
Because predicate arguments\index{argument} 
receive an assignment when calling the predicate, the
argument type-insts may include 
implicitly indexed arrays\index{array!index set!implicit}, 
as well as set variables with a
non-finite element type.}
One relaxation of argument\index{argument} 
definitions is that the index types for arrays
can be unbounded\index{array!index set!unbounded} written \texttt{int}.

Similarly, tests are defined by a statement of the form
\litblock{
\texttt{\litkw{test}} \qquote{pred-name} \texttt{(} \qquote{arg-def}, \ldots,
\qquote{arg-def} \texttt{)} \texttt{=} 
\qquote{bool-exp} 
}
\ttindexdef{test}
The \qquote{bool-exp} of the body must be fixed.


We also introduce a new form of the \texttt{assert} command for use in
predicates. 
\litblock{
\texttt{\litkw{assert}} \texttt{(} \qquote{bool-exp}, \qquote{string-exp},
\qquote{exp}
\texttt{)}
}
\ttindexdef{assert}
The type of the \texttt{assert}\ttindex{assert} 
expression\index{expression!\texttt{assert}|textbf} 
is the same as the type of the
last argument. 
The \texttt{assert} expression checks whether the first argument is false,
and if so prints the second argument string. If the first argument is true
it returns the third argument.
}

Note that assert expressions\index{expression!\texttt{assert}} 
are lazy in the third argument, that is if the
first argument is false they will not be evaluated.
Hence, they can be used for checking
\begin{code}
predicate lookup(array[int] of var int:x, int: i, var int: y) = 
    assert(i in index_set(x), "index out of range in lookup"
           y = x[i]
    );
\end{code}
This code will not evaluate $x[i]$ if $i$ is out of the range of the array
$x$.

\subsection{Defining Functions}

\index{function!definition}
Functions are defined in \ZincOrMiniZinc 
similarly to predicates, but with a more
general return type.

The function below defines the row in a Sudoku matrix
of the $a1^{th}$ row of the $a^{th}$ of subsquares
\begin{code}
function int: posn(int: a, int: a1) = (a-1) * S + a1;
\end{code}
With this definition we can replace the last constraint in the
Sudoku problem shown in \autoref{ex:sudoku} by
\begin{code}
constraint forall(a, o in SubSquareRange)( 
                  alldifferent([ puzzle [ posn(a,a0), posn(o,o1) ] | 
                                         a1,o1 in SubSquareRange ] ) );
\end{code}


Functions are useful for encoding complex expressions that
are used frequently in the model.  For example, imagine
placing the numbers 1 to $n$ in different positions
in an $n \times n$ grid such that
the Manhattan distance between any two numbers $i$ and $j$ 
is greater than the maximum of the two numbers minus 1.
The aim is to minimize the total of the Manhattan distances
between the pairs.  The Manhattan distance function
can be expressed as:
\insertlitcode{manhattan:manf}
The complete model is shown in
\autoref{ex:manhattan}.

\begin{figure}
\insertlitcode{manhattan}
\begin{litcode}{manhattan}{mzn}
int: n;
set of int: NUM = 1..n;

array[NUM] of var NUM: x;
array[NUM] of var NUM: y;
array[NUM,NUM] of var 0..2*n-2: dist = 
     array2d(NUM,NUM,[ 
     if i < j then manhattan(x[i],y[i],x[j],y[j]) else 0 endif
                     | i,j in NUM ]);

\begin{litblock}{manf}
function var int: manhattan(var int: x1, var int: y1,
                            var int: x2, var int: y2) =
         abs(x1 - x2) + abs(y1 - y2);
\end{litblock}

constraint forall(i,j in NUM where i < j)
                 (dist[i,j] >= max(i,j)-1);

var int: obj = sum(i,j in NUM where i < j)(dist[i,j]);
solve minimize obj; 

% simply to display result
include "alldifferent_except_0.mzn";
array[NUM,NUM] of var 0..n: grid;
constraint forall(i in NUM)(grid[x[i],y[i]] = i);
constraint alldifferent_except_0([grid[i,j] | i,j in NUM]);

output ["obj = \(obj);\n"] ++
       [ if fix(grid[i,j]) > 0 then show(grid[i,j]) else "." endif
         ++ if j = n  then "\n" else "" endif 
       | i,j in NUM ]; 
\end{litcode}
\caption{Model for a number placement problem illustrating 
the use of functions
(\texttt{manhattan.mzn}).\label{ex:manhattan}}
\end{figure}


\defblock{Function definitions}{
\index{function!definition|textbf}
Functions are defined by a statement of the form
\litblock{
\texttt{\litkw{function}} \qquote{ret-type} \texttt{:} \qquote{func-name} \texttt{(} \qquote{arg-def}, \ldots,
\qquote{arg-def} \texttt{)} \texttt{=} 
\qquote{exp}
}
\ttindexdef{function}
The \qquote{func-name} must be a valid \ZincOrMiniZinc identifier, and
each \qquote{arg-def} is a valid \ZincOrMiniZinc type declaration.
The \qquote{ret-type} is the return type of the function which must be
the type of \qquote{exp}. Arguments have the same restrictions as in
predicate definitions.
}

Functions in \ZincOrMiniZinc can have any return type, not just fixed
return types.
Functions are useful for defining and documenting complex expressions that
are used mulitple times in a model.




\subsection{Reflection Functions}

To help write generic tests and predicates, various reflection functions
return information about array index sets, var set domains and decision
variable ranges. Those for index sets are
\texttt{index\_set(\qquote{\emph{1-D array}})}\ttindex{index\_set},
\texttt{index\_set\_1of2(\qquote{\emph{2-D array}})}\ttindex{index\_set\_1of2},
\texttt{index\_set\_2of2(\qquote{\emph{2-D array}})}\ttindex{index\_set\_2of2} and so on for higher
dimensional arrays.

A better model of the job shop conjoins all the non-overlap constraints for a
single machine into a single disjunctive constraint.
An advantage of this approach is that while we may initially model this 
simply as a conjunction of non-overlap, if the underlying solver has a
better approach to solving disjunctive constraints we can use that instead,
with minimal changes to our model. The model is shown in
\autoref{ex:jobshop3}. 

\begin{figure}
\insertlitcode{jobshop3}
\begin{litcode}{jobshop3}{mzn}
include "disjunctive.mzn";

int: jobs;                                    % no of jobs
set of int: JOB = 1..jobs;
int: tasks;                                   % no of tasks per job
set of int: TASK = 1..tasks;
array [JOB,TASK] of int: d;                   % task durations
int: total = sum(i in JOB, j in TASK)(d[i,j]);% total duration
int: digs = ceil(log(10.0,total));            % digits for output
array [JOB,TASK] of var 0..total: s;          % start times
var 0..total: end;                            % total end time

constraint %% ensure the tasks occur in sequence
    forall(i in JOB) (
        forall(j in 1..tasks-1) 
            (s[i,j] + d[i,j] <= s[i,j+1]) /\
        s[i,tasks] + d[i,tasks] <= end
    );

constraint %% ensure no overlap of tasks
    forall(j in TASK) (
        disjunctive([s[i,j] | i in JOB], [d[i,j] | i in JOB])
    );

solve minimize end;

output ["end = \(end)\n"] ++
       [ show_int(digs,s[i,j]) ++ " " ++ 
         if j == tasks then "\n" else "" endif |
         i in JOB, j in TASK ];
\end{litcode}
\caption{Model for job shop scheduling using 
\texttt{disjunctive} predicate (\texttt{jobshop3.mzn}).\label{ex:jobshop3}}
\end{figure}

The \texttt{disjunctive}\index{global constraint!\texttt{disjunctive}} 
\ttindex{disjunctive}
constraint takes an array of start times for each
task and an array of their durations and makes sure that only one task is
active at any one
time. We define the disjunctive constraint as a predicate\index{predicate!definition} with
signature
\begin{code}
predicate disjunctive(array[int] of var int:s, array[int] of int:d);
\end{code}

We can use the disjunctive constraint to define the non-overlap of tasks as
shown in \autoref{ex:jobshop3}. 
We assume a definition for the \texttt{disjunctive} predicate is given
by the file \texttt{disjunctive.mzn} which is included in the model.
If the underlying system
supports \texttt{disjunctive} directly, it will include a file
\texttt{disjunctive.mzn} in its globals directory (with contents
just the signature definition above).
If the system we are using does not support disjunctive directly
we can give our own definition by creating the file
\texttt{disjunctive.mzn}.
The simplest implementation simply makes use of the \texttt{no\_overlap}
predicate defined above. 
A better implementation is to make use of a global \texttt{cumulative}
constraint assuming it is supported by the underlying solver.
\autoref{ex:disj} shows an implementation of \texttt{disjunctive}.
Note how we use the \texttt{index\_set} reflection function to
(a) check that the arguments to \texttt{disjunctive} make sense,
and (b) construct the array of resource utilisations of the appropriate
size for \texttt{cumulative}.
Note also that we use a ternary version of \texttt{assert} here

\begin{figure}
\insertlitcode{disjunctive}
\begin{litcode}{disjunctive}{mzn}
include "cumulative.mzn";

predicate disjunctive(array[int] of var int:s, array[int] of int:d) =
          assert(index_set(s) == index_set(d), "disjunctive: " ++
          "first and second arguments must have the same index set",
            cumulative(s, d, [ 1 | i in index_set(s) ], 1)
          );
\end{litcode}
\caption{Defining a \texttt{disjunctive} predicate 
using \texttt{cumulative} (\texttt{disjunctive.mzn}).\label{ex:disj}}
\end{figure}

\ignore{ % for capture for testing!
$ mzn-g12fd jobshop3.mzn jobshop.dzn
} % $



\subsection{Local Variables}
\index{variable!local|textbf}
It is often useful to introduce \emph{local variables} in a predicate,
function
or test. 
The \texttt{let}\ttindex{let} expression allows you to do so. 
It can be used to introduce 
both decision variables\index{variable} 
and
parameters\index{parameter}, 
but parameters must be initialised. For example: 
\begin{code}
var s..e: x;
let {int: l = s div 2; int: u = e div 2; var l .. u: y;} in x = 2*y
\end{code}
introduces parameters $l$ and $u$ and variable $y$. 
While most useful in predicate\index{predicate}, function\index{function} 
and test definitions, 
let expressions can also be used in other expressions, for example
for eliminating common subexpressions:
\begin{code}
constraint let { var int: s = x1 + x2 + x3 + x4 } in
           l <= s /\ s <= u;
\end{code}

Local variables can be used anywhere and can be quite useful, 
for simplifying complex expressions.
\autoref{ex:wedding2}
gives a revised version of the wedding model, using local variables to
define the objective\index{objective} function, 
rather than adding lots of variables
to the model explicitly.

\begin{figure}
\insertlitcode{wedding2}
\begin{litcode}{wedding2}{mzn}
enum Guests = { bride, groom, bestman, bridesmaid, bob, carol, 
  ted, alice, ron, rona, ed, clara}; 
set of int: Seats = 1..12;
set of int: Hatreds = 1..5;
array[Hatreds] of Guests: h1 = [groom, carol, ed, bride, ted];
array[Hatreds] of Guests: h2 = [clara, bestman, ted, alice, ron];
set of Guests: Males = {groom, bestman, bob, ted, ron,ed};
set of Guests: Females = {bride,bridesmaid,carol,alice,rona,clara}; 

array[Guests] of var Seats: pos; % seat of guest

include "alldifferent.mzn";
constraint alldifferent(pos);

constraint forall(g in Males)( pos[g] mod 2 == 1 );
constraint forall(g in Females)( pos[g] mod 2 == 0 );

constraint not (pos[ed] in {1,6,7,12});
constraint abs(pos[bride] - pos[groom]) <= 1 /\ 
           (pos[bride] <= 6 <-> pos[groom] <= 6);

solve maximize sum(h in Hatreds)(
          let {  var Seats: p1 = pos[h1[h]];
                 var Seats: p2 = pos[h2[h]];
                 var 0..1: same = bool2int(p1 <= 6 <-> p2 <= 6); } in   
          same * abs(p1 - p2) + (1-same) * (abs(13 - p1 - p2) + 1));

output [ show(g)++" " | s in Seats,g in Guests where fix(pos[g]) == s]
       ++ ["\n"]; 
\end{litcode}
\caption{Using local variables to define a complex objective function
  (\texttt{wedding2.mzn})\label{ex:wedding2}}
\end{figure}

\subsection{Context}
\index{context|textbf}

One limitation is that predicates and functions 
containing decision variables that are not
initialised in the declaration cannot be used inside a negative
context\index{predicate}\index{function}\index{context!negative}.
The following is illegal
\begin{code}
predicate even(var int:x) = 
          let { var int: y } in x = 2 * y;

constraint not even(z);
\end{code}
The reason for this is that solvers only solve existentially constrained
problems, and if we introduce a local variable in a negative context, then
the variable is \emph{universally quantified} and hence out of scope of the
underlying solvers. For example the $\neg even(z)$ is equivalent to
$\neg \exists y. z = 2y$ which is equivalent to
$\forall y. z \neq 2y$.

If local variables are given values, then they can be used in negative 
contexts. The following is legal
\begin{code}
predicate even(var int:x) = 
          let { var int: y = x div 2; } in x = 2 * y;

constraint not even(z);
\end{code}
Note that the meaning of \texttt{even} is correct, since if $x$ is even
then $x = 2 * (x ~\mbox{div}~ 2)$. Note that for this definition
$\neg even(z)$ is equivalent to
$\neg \exists y. y = z ~div~ 2 \wedge z = 2y$ which is equivalent to
$\exists y. y = z ~div~ 2 \wedge \neg z \neq 2y$, because $y$ is
functionally defined by $z$.


Every expression in \ZincOrMiniZinc appears in one of the four
\emph{contexts}: root\index{context!root}, positive\index{context!positive},
negative\index{context!negative},
or mixed\index{context!mixed}.
The context of a non-Boolean expression is simply the context of its nearest
enclosing Boolean expression. The one exception is that the objective
expression appears in a root context (since it has no enclosing Boolean expression).

For the purposes of defining contexts we assume implication expressions
$e$ \verb+->+ $e'$ are rewritten equivalently as \texttt{not} $e$ \verb+\/+
$e'$,
and similarly $e$ \verb+<-+ $e'$ are rewritten as  $e$ \verb+->+
\texttt{not} $e'$.

The context for a Boolean expression is given by:
\ZincOrMiniZinc:
\begin{description}
  \item[root] root context is the context for any expression $e$ appearing as
    the argument of \texttt{constraint}\ttindex{constraint} or as an
    assignment item\index{assignment}, or appearing as an sub expression $e$
    or $e'$ in an expression $e$ \verb+/\+ $e'$ occuring in a root context.

    Root context Boolean expressions must hold in any model of the problem.
    \item[positive] positive context is the context for any expression
      appearing as a sub expression $e$
      or $e'$ in an expression $e$ \verb+\/+ $e'$ occuring in a root
      or positive context,
      appearing as a sub expression $e$
      or $e'$ in an expression $e$ \verb+/\+ $e'$ occuring in a positive context,
      or appearing as a sub expression $e$ in an expression
      \texttt{not}\ttindex{not} $e$ appearing in a negative context.

      Positive context Boolean expressions need not hold in a model, but
      making them hold will only increase the possibility that the enclosing
      constraint holds. A positive context expression has an even number of
      negations in the path from the enclosing root context to the expression.
    \item[negative] positive context is the context for any expression
      appearing in a root context, or appearing as a sub expression $e$
      or $e'$ in an expression $e$ \verb+\/+ $e'$ or  $e$ \verb+/\+ $e'$ occuring in a negative,
      or appearing as a sub expression $e$ in an expression
      \texttt{not}\ttindex{not} $e$ appearing in a positive context.

      Negative context Boolean expressions need not hold in a model, but
      making them false will increase the possibility that the enclosing
      constraint holds. A negative context expression has an odd number of
      negations in the path from the enclosing root context to the expression.
    \item[mixed] mixed context is the context for any Boolean expression appearing
      as a subexpression $e$ or $e'$ in $e$ \verb+<->+ $e'$, $e$ \verb+=+
      $e'$, or \texttt{bool2int}\ttindex{bool2int}($e$),
      
      Mixed context expression are effectively both positive and
      negative. This can be seen from the fact that $e \leftrightarrow e'$ is equivalent
      to $(e \wedge e') \vee (\neg e \vee \ne e')$ and
      \texttt{bool2int}($e$) is equivalent to $(e \wedge x = 1) \vee (\neg e
      \wedge x = 0)$.       
\end{description}

Consider the code fragment
\begin{code}
  constraint x > 0 /\ (i <= 4 -> x + bool2int(x > i) = 5);
\end{code}
then \texttt{x > 0} is in the root context, \texttt{i <= 4} is in a negative
context,
\texttt{x + bool2int(x > i) = 5}
is in a positive context, and \texttt{x > i} is in a mixed context.


\subsection{Local Constraints}
\index{constraint!local}

Let expressions can also be used to include local constraints,
usually to constrain the behaviour of local variables.
For example, consider defining a square root function making use
of only multiplication:
\begin{code}
function var float: mysqrt(var float:x) = 
         let { var float: y;
               constraint y >= 0;
               constraint x = y * y; } in y;
\end{code}
The local constraints ensure
\texttt{y} takes the correct value; which is then returned
by the function.    

Local constraint can be used in any let expression, 
though the most common
usage is in defining functions.


\defblock{Let expressions}{
\index{expression!let|textbf}
Local variables\index{variable!local} 
can be introduced in any expression with a \emph{let
  expression}
of the form:
\litblock{
\texttt{\litkw{let} \{}  \qquote{dec}; \ldots \qquote{dec}; \texttt{
  \} 
\litkw{in}} \qquote{\emph{exp}}
}
\ttindexdef{let}
The declarations \qquote{dec} 
can be declarations of decision variables and
parameters (which must be initialised) or constraint items.
No declaration can make use of a newly declared variable 
before it is introduced. 

Note that local variables and constraints 
cannot occur in tests.
Local variables cannot occur in predicates 
or functions that appear in a
negative or mixed context,\index{context!negative}\index{context!mixed} 
unless the variable is defined by an expression.
}


\subsection{Domain Reflection Functions}
\index{domain!reflection}

Other important reflection functions are those that allow us to access
the domains of variables. The expression \texttt{lb(x)}\ttindex{lb}
\index{domain!\texttt{lb}} 
returns
a value that is lower than or equal to any value that $x$ may take in
a solution of the problem. Usually it will just be the
declared lower bound of $x$.\index{variable!bound} 
If $x$ is declared as a non-finite type, e.g. 
simply \texttt{var int}\index{\texttt{var}!\texttt{int}}
then it is an error. 
Similarly the expression \texttt{dom(x)}\ttindex{dom}
\index{domain!\texttt{dom}} 
returns a (non-strict) 
superset of the possible values of $x$ in any solution of the problem.
Again it is usually the declared values, and again if it is not
declared as finite then there is an error.

\ignore{ % for capture for testing!
$ mzn-g12fd reflection.mzn
} % $

\begin{figure}
\insertlitcode{reflection}
\begin{litcode}{reflection}{mzn}
var -10..10: x;
constraint x in 0..4;
int: y = lb(x);
set of int: D = dom(x);
solve satisfy;
output ["y = ", show(y), "\nD = ", show(D), "\n"];
\end{litcode}
\caption{Using reflection predicates (\texttt{reflection.mzn
    })\label{ex:reflect}}
\end{figure}

For example, the model show in \autoref{ex:reflect}
may output
\begin{cmd}
y = -10
D = -10..10
----------
\end{cmd}
or
\begin{cmd}
y = 0
D = {0, 1, 2, 3, 4}
----------
\end{cmd}
or any answer with 
$-10 \leq y \leq 0$ and 
$\{0, \ldots, 4\} \subseteq D \subseteq \{-10, \ldots, 10\}$.

Variable domain reflection expressions should be used in a manner where they are
correct for any safe approximations, but note this is not checked!
For example the additional code
\begin{code}
var -10..10: z;
constraint z <= y;
\end{code}
is not a safe usage of the domain information. 
Since using the tighter (correct) approximation leads to 
more solutions than the weaker initial approximation.


\defblock{Domain reflection}{
\index{domain!reflection|textbf}
There are reflection functions to interrogate 
the possible values of expressions containing variables:
\begin{itemize}
\item \texttt{dom} \texttt{(} \qquote{exp} \texttt{)}:\ttindexdef{dom}
returns a safe approximation to the possible values of the expression. 
\item \texttt{lb} \texttt{(} \qquote{exp} \texttt{)}:\ttindexdef{lb}
returns a safe approximation to the lower bound value of the expression. 
\item \texttt{ub} \texttt{(} \qquote{exp} \texttt{)}:\ttindexdef{ub}
returns a safe approximation to the upper bound value of the expression. 
\end{itemize}
The expressions for \texttt{lb} and \texttt{ub}
can only be of types \texttt{int}, \texttt{bool},
\texttt{float} or \texttt{set of int}.
For \texttt{dom} the type cannot be \texttt{float}.
If one of the variables appearing in $exp$ has a 
non-finite declared 
type\index{type!non-finite} 
(e.g. \texttt{var int} or \texttt{var float} type) 
then an error can occur.

There are also versions that work directly on arrays of expressions (with
similar restrictions):
\begin{itemize}
\item \texttt{dom\_array} \texttt{(} \qquote{array-exp} \texttt{)}:
\ttindexdef{dom\_array}
returns a safe approximation to the union of all 
possible values of the expressions appearing in the array. 
\item \texttt{lb\_array} \texttt{(} \qquote{array-exp} \texttt{)}:
\ttindexdef{lb\_array}
returns a safe approximation to the lower bound of all expressions appearing
in the array.
\item \texttt{ub\_array} \texttt{(} \qquote{array-exp} \texttt{)}:
\ttindexdef{ub\_array}
returns a safe approximation to the upper bound of all expressions appearing
in the array.
\end{itemize}
}

The combinations of predicates, local variables and domain reflection
allows the definition of complex global constraints by decomposition.
We can define the time based decomposition 
of the \texttt{cumulative}\ttindex{cumulative}
constraint using the code shown in \autoref{ex:cumul}.

\begin{figure}
\insertlitcode{cumulative}
\begin{litcode}{cumulative}{mzn}
%--------------------------------------------------------------------%
% Requires that a set of tasks given by start times 's', 
% durations 'd', and resource requirements 'r', 
% never require more than a global 
% resource bound 'b' at any one time.
% Assumptions:
% - forall i, d[i] >= 0 and r[i] >= 0
%--------------------------------------------------------------------%
predicate cumulative(array[int] of var int: s,
                     array[int] of var int: d,
                     array[int] of var int: r, var int: b) =
   assert(index_set(s) == index_set(d) /\ 
          index_set(s) == index_set(r),
     "cumulative: the array arguments must have identical index sets",
   assert(lb_array(d) >= 0 /\ lb_array(r) >= 0,
     "cumulative: durations and resource usages must be non-negative",
           let { 
               set of int: times =
                 lb_array(s) ..
                 max([ ub(s[i]) + ub(d[i]) | i in index_set(s) ]) 
               } 
           in
              forall( t in times ) (
                 b >= sum( i in index_set(s) ) (
                    bool2int( s[i] <= t /\ t < s[i] + d[i] ) * r[i]
                 )
              )
       )
   );
\end{litcode}
\caption{Defining a \texttt{cumulative} predicate 
by decomposition (\texttt{cumulative.mzn}).\label{ex:cumul}}
\end{figure}

The decomposition uses \texttt{lb} and \texttt{ub} to determine
the set of times \texttt{times} over which tasks could range.
It then asserts for each time $t$ in \texttt{times} that the
sum of resources for the active tasks at time $t$ is less than
the bound $b$.

\subsection{Scope}
\index{scope}

It is worth briefly mentioning the scope of declarations in \ZincOrMiniZinc.
\ZincOrMiniZinc has a single namespace, so all variables appearing 
in declarations are visible in every expression in the model.
\ZincOrMiniZinc introduces locally scoped
variables in a number of ways:
\begin{itemize}
\item  as iterator\index{variable!iterator} 
variables in comprehension expressions\index{comprehension}
\item using \texttt{let}\ttindex{let} expressions
\item as predicate and function arguments\index{argument}
\end{itemize}
Any local scoped variable overshadows the outer scoped variables
of the same name.

\begin{figure}
\insertlitcode{scope}
\begin{litcode}{scope}{mzn}
int: x = 3;
int: y = 4;
predicate smallx(var int:y) = -x <= y /\ y <= x;
predicate p(int: u, var bool: y) = 
      exists(x in 1..u)(y \/ smallx(x));
constraint p(x,false);
solve satisfy;
\end{litcode}
\caption{A model for illustrating scopes of variables
  (\texttt{scope.mzn})\label{ex:scope}}
\end{figure}

For example, in the model shown in \autoref{ex:scope} 
the \texttt{x} in \texttt{-x <= y} is the global \texttt{x},
the \texttt{x} in
\texttt{even(x)} is the iterator \texttt{x in 1..u},
while the \texttt{y} in the disjunction is the second
argument of the predicate.


